//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : OC
//  @ File Name : DEMFileRead.h
//  @ Date : 2011-10-21
//  @ Author : 
//
//

#ifndef DEM_READER_H_
#define DEM_READER_H_

#include "Comlib.h"
#include "ogr_srs_api.h"     //spatialref
#include "gdal_alg.h"        //gdal algrithom
#include "cpl_string.h"      //string manipulation

enum ALGOLIB_API DEMType{
	FREE_90_DEM,
	FREE_30_DEM,
	VRSS_DEM,
	NO_CHOICE
};

enum DEMGetMode{
	CGEO_MODE,
	GGEO_MODE
};

#ifndef MAX_GROUND_HEIGHT
#define MAX_GROUND_HEIGHT 8845
#endif

#ifndef MIN_GROUND_HEIGHT
#define MIN_GROUND_HEIGHT -400
#endif

#ifndef MAX_FILE_PATH_LENGTH
#define MAX_FILE_PATH_LENGTH 512
#endif

#ifndef MAX_FILE_NAME_LENGTH
#define MAX_FILE_NAME_LENGTH 256
#endif

#define invalid_value  999999999999

#define strDirSec "\\"

class ALGOLIB_API CDEMFileRead 
{
public:
	CDEMFileRead();
	virtual ~CDEMFileRead();
	
public:
	CDEMFileRead& operator=(const CDEMFileRead& other);
	
public:
	int  InitBlockElevation(double longUpperLeft, double latUpperLeft, double longUpperRight, double latUpperRight,
		double longLowerRight, double latLowerRight, double longLowerLeft, double latLowerLeft, DEMType prioDEMType);
	int  InitBlockElevation(double leftLon, double rightLon, double upLat, double downLat, DEMType prioDEMType);

	void setDEMFilePath(const char *str30DemFilePath, const char *str90DemFilePath, const char *strVRSSDemFilePath);
	void setDEMFilePath(const char *strDemFilePath);

	double  GetAverageElevation();
	double  maxDEMElement();
	double  minDEMElement();
	
	int outputDEMData(const char *demReultFile);
	
	double GetElevation(double lat, double lon);
	double GetElevationD(double X, double Y);
	int getDEMBlockInfo(int &width, int &height, double &gnd, double &startLon, double &startLat,  char *&strwkt);

private:
	void closeDEMIO();
	int Free30DEM(double leftLon, double rightLon, double upLat, double bottomLat);
	int Free90DEM(double leftLon, double rightLon, double upLat, double bottomLat);
	int VRSS90DEM(double leftLon, double rightLon, double upLat, double bottomLat);

	void Free30DemGetFileName(double lat, double lon, char *fileName);
	void Free90DemGetFileName(double lat, double lon, char *fileName);
	void VRSS90DemGetFileName(double lat, double lon, char *fileName);

	double GetElevationFromFile(double lat, double lon);

	int CGeoCut(short *mosaicData, int mosaicWidth, int mosaicHeight, double mosaicLeftLon, double mosaicUpLat, 
		double stepGridDegree, double leftLon, double rightLon, double upLat, double bottomLat);

	int fCGeoCut(float *mosaicData, int mosaicWidth, int mosaicHeight, double mosaicLeftLon, double mosaicUpLat, 
		double stepGridDegree, double leftLon, double rightLon, double upLat, double bottomLat);
	
	int NANProcess();
				
	bool pixelToWorld(double x, double  y, double *lat, double *lon, double* geotransform, const char* lpszSR);

	bool worldToPixel(double lat, double lon, double *x, double *y, double* geoTransform, const char* lpszSR);

	void debugfortestWriteFile(char *fileName, int width, int hegith, void *databuff, int nbyte);

private:
public:
	DEMType         m_demType; 
	int                    m_initBlockTag;
	char               *m_strFree90DemFilePath;
	char               *m_strFree30DemFilePath;
	char               *m_strVRSSDemFilePath;

private:
	double          m_leftLon;
	double          m_rightLon;
	double          m_upLat;
	double          m_bottomLat;
	double          m_stepGridDegree;

	int                m_width;
	int                m_height;
	short           *m_sdemData;

	//for VRSS DEM data
	float            *m_fdemData;
	double          m_fRatioLevel;

	char            *m_wktString;
	OGRSpatialReferenceH                m_hSRS;
	OGRSpatialReferenceH                m_latLongSR;
	OGRCoordinateTransformationH m_latLon2GndpoTransform;
	OGRCoordinateTransformationH m_gnd2LatLonpoTransform;

private:
	template<class T>
	T Bilinear(float xrp, float yrp,int xosize,int yosize,	const T* input_image)
	{
		int x[2],y[2],x0,x1,x2,x3;
		float cx,cy,cx1,cy1,zz;
		/***********************************************************************
		* Find four pixel's (x,y) coordinate which closest to (xrp,yrp)        *
		* and calculate the cx and cy                                          *
		***********************************************************************/
		x[0]=(int)xrp; x[1]=x[0]+1; cx=xrp-(float)x[0]; cx1=1-cx;
		y[0]=(int)yrp; y[1]=y[0]+1; cy=yrp-(float)y[0]; cy1=1-cy;

		
		if(x[0]<0 || y[0]<0) 
			return 0;
		
		if(x[0]>=xosize || y[0]>=yosize) /* Boundary handle */
			return 0;
		
		else if(x[1]>=xosize || y[1]>=yosize) /* Boundary handle */
		{
			return input_image[y[0]*xosize+x[0]];
		}
		
		else /* Interpolation */
		{
			x0=y[0]*xosize+x[0];
			x1=x0+1;
			x2=x0+xosize;
			x3=x2+1;
			zz=((unsigned char)(input_image[x0])*cy1*cx1+(unsigned char)(input_image[x2])*cy*cx1+
					(unsigned char)(input_image[x1])*cy1*cx+(unsigned char)(input_image[x3])*cy*cx+(float)0.5);
		}
		zz=(zz<0)?0:zz;
		return((T)zz);
	}

public:	
	
	//unsigned char *m_pVRSSDemBuffer;
	//int            m_VRSSImageWidth;
	//int            m_VRSSImageHeight;
	//double         m_VRSSUpLeftX;
	//double         m_VRSSUpLeftY;
	//double         m_VRSSLatitudeGrid;
	//double         m_VRSSLongitudeGrid;
	//char          *m_wktString;
};

#endif /*DEM_READER_H_*/
