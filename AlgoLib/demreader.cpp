//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : OC
//  @ File Name : DEMFileRead.cpp
//  @ Date : 2011-10-21
//  @ Author : 
//
//
#include "demreader.h"

#include <io.h>
#include <stdlib.h>
#include <stdio.h>
#include <algorithm>

#include "gdalfilemanager.h"

using namespace std;

CDEMFileRead::CDEMFileRead()
{
	m_strFree30DemFilePath = NULL;
	m_strFree90DemFilePath = NULL;
	m_strVRSSDemFilePath = NULL;
	m_initBlockTag = 0;
	m_demType = NO_CHOICE;

	m_sdemData = NULL;

	m_fdemData = NULL; 
	m_wktString = NULL;
}

CDEMFileRead::~CDEMFileRead() 
{
	if (m_strFree30DemFilePath!=NULL)
	{
		delete [] m_strFree30DemFilePath ; m_strFree30DemFilePath =NULL;
	}
	if (m_strFree90DemFilePath!=NULL)
	{
		delete [] m_strFree90DemFilePath ; m_strFree90DemFilePath =NULL;
	}
	if (m_strVRSSDemFilePath!=NULL)
	{
		delete [] m_strVRSSDemFilePath ; m_strVRSSDemFilePath =NULL;
	}

	closeDEMIO();
}

void CDEMFileRead::closeDEMIO()
{

	m_initBlockTag = 0;
	m_demType = NO_CHOICE;

	if (m_sdemData != NULL)
	{
		delete [] m_sdemData; m_sdemData=NULL;
	}

	if (m_fdemData != NULL)
	{
		delete [] m_fdemData; m_fdemData=NULL;
	}
}

int CDEMFileRead::InitBlockElevation(double longUpperLeft, double latUpperLeft, double longUpperRight, double latUpperRight,
		double longLowerRight, double latLowerRight, double longLowerLeft, double latLowerLeft, DEMType prioDEMType)
{
	double longitArray[4];
	double latitArray[4];
	
	longitArray[0] = longUpperLeft;
	longitArray[1] = longUpperRight;
	longitArray[2] = longLowerRight;
	longitArray[3] = longLowerLeft;
	
	latitArray[0] = latUpperLeft;
	latitArray[1] = latUpperRight;
	latitArray[2] = latLowerRight;
	latitArray[3] = latLowerLeft;
	
	double leftLon   = *(min_element(longitArray, longitArray+4));
	double rightLon = *(max_element(longitArray, longitArray+4));
	double upLat     = *(max_element(latitArray,  latitArray+4));
	double downLat= *(min_element(latitArray,  latitArray+4));

	return InitBlockElevation(leftLon, rightLon, upLat, downLat, prioDEMType);
}


int CDEMFileRead::InitBlockElevation(double leftLon, double rightLon, double upLat, double downLat, DEMType prioDEMType)
{
	closeDEMIO();

	m_initBlockTag = 1;

	int image_zone = (int)((leftLon+rightLon+360)/12)+1;
	m_hSRS = OSRNewSpatialReference(NULL);
	OSRSetWellKnownGeogCS(m_hSRS, "WGS84" );
	if ((upLat+downLat)/2>0)
		OSRSetUTM(m_hSRS, image_zone, 1);	
	else
		OSRSetUTM(m_hSRS, image_zone, 0);

	OSRExportToWkt( m_hSRS, &m_wktString);

	m_latLongSR= OSRNewSpatialReference(NULL);  //geo
	OSRSetWellKnownGeogCS(m_latLongSR, "WGS84" );

	m_latLon2GndpoTransform =OCTNewCoordinateTransformation(m_latLongSR, m_hSRS);
	m_gnd2LatLonpoTransform =OCTNewCoordinateTransformation(m_hSRS, m_latLongSR);

	int retval = 0;
	if (FREE_30_DEM==prioDEMType)
	{
		retval =Free30DEM(leftLon, rightLon, upLat, downLat); 
	}
	else if(FREE_90_DEM== prioDEMType)
	{
		retval =Free90DEM(leftLon, rightLon, upLat, downLat); 
	}
	else if(VRSS_DEM==prioDEMType)
	{
		retval =VRSS90DEM(leftLon, rightLon, upLat, downLat); 
	}
	else
	{
		retval = -1;
	}

	if (retval==0)
	{
		m_demType = prioDEMType;
	}
	else{
		m_demType = FREE_30_DEM;
		if(Free30DEM(leftLon, rightLon, upLat, downLat)!=0)
		{
			m_demType = FREE_90_DEM;
			if(Free90DEM(leftLon, rightLon, upLat, downLat)!=0)
			{
				return -1;
			}
		}
	}

	return 0;
}


void CDEMFileRead::setDEMFilePath(const char *str30DemFilePath, const char *str90DemFilePath, const char *strVRSSDemFilePath)
{
	if (m_strFree30DemFilePath!=NULL)
	{
		delete [] m_strFree30DemFilePath ; m_strFree30DemFilePath =NULL;
	}
	if (m_strFree90DemFilePath!=NULL)
	{
		delete [] m_strFree90DemFilePath ; m_strFree90DemFilePath =NULL;
	}
	if (m_strVRSSDemFilePath!=NULL)
	{
		delete [] m_strVRSSDemFilePath ; m_strVRSSDemFilePath =NULL;
	}

	m_strFree30DemFilePath = new char[512];
	m_strFree90DemFilePath = new char[512];
	m_strVRSSDemFilePath   = new char[512];
	if (str30DemFilePath!=NULL){
		strcpy(m_strFree30DemFilePath, str30DemFilePath);
	}
	if (str90DemFilePath!=NULL){
		strcpy(m_strFree90DemFilePath, str90DemFilePath);
	}
	if (strVRSSDemFilePath!=NULL){
		strcpy(m_strVRSSDemFilePath, strVRSSDemFilePath);
	}

	if (m_strFree30DemFilePath[strlen(m_strFree30DemFilePath)]!='\\')
	{
		strcat(m_strFree30DemFilePath, "\\");
	}
	if (m_strFree90DemFilePath[strlen(m_strFree90DemFilePath)]!='\\')
	{
		strcat(m_strFree90DemFilePath, "\\");
	}
	if (m_strVRSSDemFilePath[strlen(m_strVRSSDemFilePath)]!='\\')
	{
		strcat(m_strVRSSDemFilePath, "\\");
	}
}

int CDEMFileRead::getDEMBlockInfo(int &width, int &height, double &gnd, double &startLon, double &startLat, char *&strwkt)
{
	width = m_width;
	height= m_height;
	gnd    = m_stepGridDegree;
	startLon = m_leftLon;
	startLat  = m_upLat;

     OGRSpatialReferenceH latLongSR= OSRNewSpatialReference(NULL); 
	OSRSetWellKnownGeogCS(latLongSR, "WGS84" );
	OSRExportToWkt(latLongSR, &strwkt);

	return 0;
}

void CDEMFileRead::setDEMFilePath(const char *strDemFilePath)
{
	if (m_strFree30DemFilePath!=NULL)
	{
		delete [] m_strFree30DemFilePath ; m_strFree30DemFilePath =NULL;
	}
	if (m_strFree90DemFilePath!=NULL)
	{
		delete [] m_strFree90DemFilePath ; m_strFree90DemFilePath =NULL;
	}
	if (m_strVRSSDemFilePath!=NULL)
	{
		delete [] m_strVRSSDemFilePath ; m_strVRSSDemFilePath =NULL;
	}

	m_strFree30DemFilePath = new char[512];
	m_strFree90DemFilePath = new char[512];
	m_strVRSSDemFilePath   = new char[512];
	if (strDemFilePath!=NULL){
		strcpy(m_strFree30DemFilePath, strDemFilePath);
		strcpy(m_strFree90DemFilePath, strDemFilePath);
		strcpy(m_strVRSSDemFilePath, strDemFilePath);
	}

	if (m_strFree30DemFilePath[strlen(m_strFree30DemFilePath)]!='\\')
	{
		strcat(m_strFree30DemFilePath, "\\");
	}
	if (m_strFree90DemFilePath[strlen(m_strFree90DemFilePath)]!='\\')
	{
		strcat(m_strFree90DemFilePath, "\\");
	}
	if (m_strVRSSDemFilePath[strlen(m_strVRSSDemFilePath)]!='\\')
	{
		strcat(m_strVRSSDemFilePath, "\\");
	}
}

double CDEMFileRead::GetAverageElevation()
{
	int i, j;
	double	bloSize = m_width*m_height;
	if (m_initBlockTag==1)
	{
		double val = 0;
		if (m_sdemData!=NULL)
		{
			for (i=0; i<m_height; i++)
			{
				for (j=0; j<m_width; j++)
				{
					val += ((m_sdemData[i*m_width+j])/bloSize);
				}
			}
		}
		else if(m_fdemData!=NULL)
		{
			for (i=0; i<m_height; i++)
			{
				for (j=0; j<m_width; j++)
				{
					val += ((m_fdemData[i*m_width+j])/bloSize);
				}
			}
		}
		return val;
	}
	else
	{
		return invalid_value;
	}
	
	return invalid_value;
}

int CDEMFileRead::outputDEMData(const char *demReultFile)
{
	if (m_initBlockTag!=1)
	{
		return -1;
	}

	if(demReultFile!=NULL)
	{
		FILE *fpDemFile = NULL;
		if((fpDemFile= fopen(demReultFile,"wb"))==NULL)
		{
			return -1;
		}
		
		if(m_demType==VRSS_DEM)
		{
			//add VRSS DEM data
		}
		else{
			fwrite(m_sdemData, m_width*m_height, sizeof(unsigned short), fpDemFile);
		}
		
		fclose(fpDemFile); fpDemFile=NULL;
	}
	else 
	{
		return -1;
	}
	
	return 0;
}

double CDEMFileRead::maxDEMElement()
{
	if (m_initBlockTag==1)
	{
		double val = 0;
		if (m_sdemData!=NULL)
		{
			val = *(max_element(m_sdemData, m_sdemData+m_width*m_height));
		}
		else if(m_fdemData!=NULL)
		{
			val = *(max_element(m_fdemData, m_fdemData+m_width*m_height))*m_fRatioLevel;
		}
		return val;
	}
	else
	{
		return invalid_value;
	}

	return invalid_value;
}

double CDEMFileRead::minDEMElement()
{
	if (m_initBlockTag==1)
	{
		double val = 0;
		if (m_sdemData!=NULL)
		{
			val = *(min_element(m_sdemData, m_sdemData+m_width*m_height));
		}
		else if(m_fdemData!=NULL)
		{
			val = *(min_element(m_fdemData, m_fdemData+m_width*m_height))*m_fRatioLevel;
		}
		return val;
	}
	else
	{
		return invalid_value;
	}
	
	return invalid_value;
}

int CDEMFileRead::Free30DEM(double leftLon, double rightLon, double upLat, double bottomLat)
{
	//define the variable
	int i, j, m, n;
	i = j = m = n = 0;

	double latGrid        = 1.0;
	double lonGrid       = 1.0;
	m_stepGridDegree = latGrid/3600;
	int demGridColStartPos, demGridColEndPos, demGridRowStartPos, demGridRowEndPos;

	demGridColStartPos    = int(leftLon);
	demGridColEndPos      = int(rightLon);
	demGridRowStartPos  = int(bottomLat);
	demGridRowEndPos    = int(upLat);

	//------------step 2: mosaic the dem data--------------------//
	short      *pMosaicDEMData;
	int           mosaicWidth;
	int           mosaicHeight;
	double    mosaicLeftLon;
//	double    mosaicRightLon;
	double    mosaicUpLat;
//	double    mosaicBottomLat;

	mosaicLeftLon      =demGridColStartPos;
	mosaicUpLat        =demGridRowEndPos+1;

	mosaicWidth  = (demGridColEndPos-demGridColStartPos+1)*3600;
	mosaicHeight = (demGridRowEndPos-demGridRowStartPos+1)*3600;

	pMosaicDEMData = new short[mosaicWidth*mosaicHeight];
	memset(pMosaicDEMData, 0, mosaicWidth*mosaicHeight*sizeof(short));

	short *blockDEMData = new short[3601*3601];
	memset(blockDEMData, 0, 3601*3601*sizeof(short));

	int bandArrayList[] = {1};

	char tempDemPathName[512];
	CGDALFileManager* gdalImage = NULL;

	int validTag = 0;

	double tempGridCenterLon, tempGridCenterLat;
	int blockStartX, blockStartY;
	for (i=demGridRowEndPos; i>=demGridRowStartPos; i--)
	{
		for (j=demGridColStartPos; j<=demGridColEndPos; j++)
		{
			tempGridCenterLon = j+0.5;
			tempGridCenterLat  = i+0.5;

			Free30DemGetFileName(tempGridCenterLat, tempGridCenterLon, tempDemPathName);

			blockStartX = (j-demGridColStartPos)*3600;
			blockStartY = (demGridRowEndPos-i)*3600;

			if( (_access(tempDemPathName, 4 )) == -1 )
			{
				printf("can't access the image: %s\n", tempDemPathName);
				continue;
			}
			else
			{
				validTag = 1;

				gdalImage = new CGDALFileManager;

				if (gdalImage->LoadFrom(tempDemPathName) == false)
				{
					printf("load image error: %s\n", tempDemPathName);
					return -1;
				}

				memset(blockDEMData, 0, 3601*3601*sizeof(short));
				gdalImage->ReadImg(0, 0, 3601, 3601, blockDEMData, 3601, 3601, 1, bandArrayList, 0, 0, 0);

				for (m=0; m< 3600 ; m++)
				{
					memcpy(pMosaicDEMData+(blockStartY+m)*mosaicWidth+blockStartX, blockDEMData+m*3601,  3600*sizeof(short));
				}

				delete gdalImage; gdalImage=NULL;
			}
		}
	}

	CGeoCut(pMosaicDEMData, mosaicWidth, mosaicHeight, mosaicLeftLon, mosaicUpLat, m_stepGridDegree, leftLon, rightLon, upLat, bottomLat);

	delete [] pMosaicDEMData; pMosaicDEMData=NULL;
	delete [] blockDEMData; blockDEMData=NULL;

	NANProcess();

	if (validTag==0)
	{
		return -1;
	}

	return 0;
}
int CDEMFileRead::Free90DEM(double leftLon, double rightLon, double upLat, double bottomLat)
{
	//define the variable
	int i, j, m, n;
	i = j = m = n = 0;
	
	double latGrid    = 5.0;
	double lonGrid   = 5.0;
	m_stepGridDegree = latGrid/6000;
	int demGridColStartPos, demGridColEndPos, demGridRowStartPos, demGridRowEndPos;

	demGridColStartPos    = int((leftLon+180)/lonGrid)+1;
	demGridColEndPos      = int((rightLon+180)/lonGrid)+1;
	demGridRowStartPos  = int((60.0-upLat)/latGrid)+1;
	demGridRowEndPos    = int((60.0-bottomLat)/latGrid)+1;
	
	//------------step 2: mosaic the dem data--------------------//
	short      *pMosaicDEMData;
	int           mosaicWidth;
	int           mosaicHeight;
	double    mosaicLeftLon;
	double    mosaicRightLon;
	double    mosaicUpLat;
	double    mosaicBottomLat;

	mosaicWidth  = (demGridColEndPos-demGridColStartPos+1)*6000;
	mosaicHeight = (demGridRowEndPos-demGridRowStartPos+1)*6000;

	mosaicLeftLon      =(demGridColStartPos-1)*5-180;
	mosaicRightLon    =(demGridColEndPos)*5-180;
	mosaicUpLat        =60-(demGridRowStartPos-1)*5;
	mosaicBottomLat =60-(demGridRowEndPos)*5;

	pMosaicDEMData = new short[mosaicWidth*mosaicHeight];
	memset(pMosaicDEMData, 0, mosaicWidth*mosaicHeight*sizeof(short));

	short *blockDEMData = new short[6000*6000];

	int bandArrayList[] = {1};

	char tempDemPathName[512];
	CGDALFileManager* gdalImage = NULL;

	double tempGridCenterLon, tempGridCenterLat;

	int validTag = 0;

	int blockStartX, blockStartY;
	for (i=demGridRowStartPos; i<=demGridRowEndPos; i++)
	{
		for (j=demGridColStartPos; j<=demGridColEndPos; j++)
		{
			tempGridCenterLon = (j-1)*lonGrid-180.0+2.5;
			tempGridCenterLat  = 60.0-((i-1)*latGrid)-2.5;

			Free90DemGetFileName(tempGridCenterLat, tempGridCenterLon, tempDemPathName);

			blockStartX = (j-demGridColStartPos)*6000;
			blockStartY = (i-demGridRowStartPos)*6000;

			if( (_access(tempDemPathName, 4 )) == -1 )
			{
				printf("can't access the image: %s\n", tempDemPathName);
				continue;
			}
			else
			{
				validTag = 1;

				gdalImage = new CGDALFileManager;

				if (gdalImage->LoadFrom(tempDemPathName) == false)
				{
					printf("load image error: %s\n", tempDemPathName);
					return -1;
				}

				memset(blockDEMData, 0, 6000*6000*sizeof(short));
				gdalImage->ReadImg(0, 0, 6000, 6000, blockDEMData, 6000, 6000, 1, bandArrayList, 0, 0, 0);

				for (m=0; m< 6000 ; m++)
				{
					memcpy(pMosaicDEMData+(blockStartY+m)*mosaicWidth+blockStartX, blockDEMData+m*6000,  6000*sizeof(short));
				}

				delete gdalImage; gdalImage=NULL;
			}
		}
	}

	//cut image
	CGeoCut(pMosaicDEMData, mosaicWidth, mosaicHeight, mosaicLeftLon, mosaicUpLat, m_stepGridDegree, leftLon, rightLon, upLat, bottomLat);

	delete [] pMosaicDEMData; pMosaicDEMData=NULL;
	delete [] blockDEMData; blockDEMData=NULL;

	NANProcess();

	if (validTag==0)
	{
		return -1;
	}

	return 0;
}

int CDEMFileRead::VRSS90DEM(double leftLon, double rightLon, double upLat, double bottomLat)
{	
	// 5 degree <---------->6000 pixcel//
	// 1 degree <---------->1200 pixcel//
	// one block(30', 20') <---------> (600, 400) pixcel//

	m_stepGridDegree = 5/6000;

	int i, j, m, n;
	i = j = m = n = 0;
	int demGridColStartPos, demGridColEndPos, demGridRowStartPos, demGridRowEndPos;
	demGridColStartPos    = int(leftLon*2);
	demGridColEndPos      = int(rightLon*2);
	demGridRowStartPos  = int(upLat*3);
	demGridRowEndPos    = int(bottomLat*3);

	//------------step 2: mosaic the dem data--------------------//
	float      *pMosaicDEMData;
	int           mosaicWidth;
	int           mosaicHeight;
	double    mosaicLeftLon;
//	double    mosaicRightLon;
	double    mosaicUpLat;
//	double    mosaicBottomLat;

	mosaicLeftLon      =demGridColStartPos*0.5;
	mosaicUpLat        =demGridRowStartPos/3;

	mosaicWidth  = (demGridColEndPos-demGridColStartPos+1)*600;
	mosaicHeight = (demGridRowEndPos-demGridRowStartPos+1)*400;

	pMosaicDEMData = new float[mosaicWidth*mosaicHeight];
	memset(pMosaicDEMData, 0, mosaicWidth*mosaicHeight*sizeof(float));

	float *blockDEMData = new float[601*401];
	memset(blockDEMData, 0, 601*401*sizeof(float));

	int bandArrayList[] = {1};

	char tempDemPathName[512];
	CGDALFileManager* gdalImage = NULL;

	double tempGridCenterLon, tempGridCenterLat;
	int blockStartX, blockStartY;
	for (i=demGridRowStartPos; i<=demGridRowEndPos; i++)
	{
		for (j=demGridColStartPos; j<=demGridColEndPos; j++)
		{
			tempGridCenterLon = j/2+1/4;
			tempGridCenterLat  = i/3+1/6;

			VRSS90DemGetFileName(tempGridCenterLat, tempGridCenterLon, tempDemPathName);

			blockStartX = (j-demGridColStartPos)*600;
			blockStartY = (i-demGridRowStartPos)*400;

			if( (_access(tempDemPathName, 4 )) == -1 )
			{
				printf("can't access the image: %s\n", tempDemPathName);
				continue;
			}
			else
			{
				gdalImage = new CGDALFileManager;

				if (gdalImage->LoadFrom(tempDemPathName) == false)
				{
					printf("load image error: %s\n", tempDemPathName);
					return -1;
				}

				memset(blockDEMData, 0, 601*401*sizeof(float));
				gdalImage->ReadImg(0, 0, 601, 401, blockDEMData, 601, 401, 1, bandArrayList, 0, 0, 0);

				for (m=0; m< 401 ; m++)
				{
					memcpy(pMosaicDEMData+(blockStartY+m)*mosaicWidth+blockStartX, blockDEMData+m*601,  600*sizeof(short));
				}

				delete gdalImage; gdalImage=NULL;
			}
		}
	}

	fCGeoCut(pMosaicDEMData, mosaicWidth, mosaicHeight, mosaicLeftLon, mosaicUpLat, m_stepGridDegree, leftLon, rightLon, upLat, bottomLat);

	delete [] pMosaicDEMData; pMosaicDEMData=NULL;
	delete [] blockDEMData; blockDEMData=NULL;

	return 0;
}


void CDEMFileRead::Free30DemGetFileName(double lat, double lon, char *fileName)
{
	char NSArray[5];
	char WEArray[5];
	if (lat>0){
		strcpy(NSArray, "N");
	}
	else{
		strcpy(NSArray, "S");
	}
	if (lon<0){
		strcpy(WEArray, "W");
	}
	else{
		strcpy(WEArray, "E");
	}

	double absLat = abs(lat);
	double absLon= abs(lon);

	int directoryLatNumber = int(absLat/10)*10;
	int directoryLonNumber= int(absLon/10)*10;
	int fileLatNumber = int(absLat);
	int fileLonNumber= int(absLon);

	strcpy(fileName, m_strFree30DemFilePath);
	sprintf(fileName, "%s%s%2d%s%3d%sASTGTM_%s%2d%s%3d_dem.tif", m_strFree30DemFilePath, NSArray, directoryLatNumber, WEArray, 
		directoryLonNumber, strDirSec, NSArray, fileLatNumber, WEArray, fileLonNumber);
	
	return;
}


void CDEMFileRead::Free90DemGetFileName(double lat, double lon, char *fileName)
{
	double latGrid    = 5.0;
	double lonGrid   = 5.0;

	int demGridCol  = int((lon+180)/lonGrid)+1;
	int demGridRow = int((60.0-lat)/latGrid)+1;

	sprintf(fileName,"%sZ_%d_%d.TIF",m_strFree90DemFilePath, demGridCol, demGridRow);

	return;
}


int CDEMFileRead::CGeoCut(short *mosaicData, int mosaicWidth, int mosaicHeight, double mosaicLeftLon, double mosaicUpLat, double stepGridDegree, 
						  double leftLon, double rightLon, double upLat, double bottomLat)
{
	//------------step 2: subset the dem data--------------------//
	int subset_x_start, subset_y_start, subset_x_end, subset_y_end; 
	subset_x_start = subset_y_start = subset_x_end = subset_y_end = 0;

	subset_x_start = int((leftLon-mosaicLeftLon)/stepGridDegree);
	subset_x_end   = int((rightLon-mosaicLeftLon)/stepGridDegree)+1;
	subset_y_start = int((mosaicUpLat-upLat)/stepGridDegree);
	subset_y_end   = int((mosaicUpLat-bottomLat)/stepGridDegree)+1;

	//check the edge
	if(subset_x_start<0) 
		subset_x_start=0;
	if(subset_y_start<0) 
		subset_y_start=0;
	if(subset_x_end>=mosaicWidth)
		subset_x_end=mosaicWidth;
	if(subset_y_end>=mosaicHeight)
		subset_y_end=mosaicHeight;

	//update the class variable
	m_width          = subset_x_end-subset_x_start;
	m_height         = subset_y_end-subset_y_start;
	m_leftLon      = mosaicLeftLon+subset_x_start*stepGridDegree;
	m_rightLon    = mosaicLeftLon+subset_x_end*stepGridDegree;
	m_upLat        = mosaicUpLat-subset_y_start*stepGridDegree;
	m_bottomLat = mosaicUpLat-subset_y_end*stepGridDegree;

	m_sdemData = new short[m_width*m_height];
	memset(m_sdemData, 0, m_width*m_height*sizeof(short));

	int i=0;
	for(i=0; i<m_height; i++)
	{
		memcpy(m_sdemData+i*m_width,  mosaicData+(i+subset_y_start)*mosaicWidth+subset_x_start, m_width*sizeof(short));
	}

	return 0;
}

int CDEMFileRead::fCGeoCut(float *mosaicData, int mosaicWidth, int mosaicHeight, double mosaicLeftLon, double mosaicUpLat, double stepGridDegree, 
						  double leftLon, double rightLon, double upLat, double bottomLat)
{
	//------------step 2: subset the dem data--------------------//
	int subset_x_start, subset_y_start, subset_x_end, subset_y_end; 
	subset_x_start = subset_y_start = subset_x_end = subset_y_end = 0;

	subset_x_start = int((leftLon-mosaicLeftLon)/stepGridDegree);
	subset_x_end   = int((rightLon-mosaicLeftLon)/stepGridDegree)+1;
	subset_y_start = int((mosaicUpLat-upLat)/stepGridDegree);
	subset_y_end   = int((mosaicUpLat-bottomLat)/stepGridDegree)+1;

	//check the edge
	if(subset_x_start<0) 
		subset_x_start=0;
	if(subset_y_start<0) 
		subset_y_start=0;
	if(subset_x_end>=mosaicWidth)
		subset_x_end=mosaicWidth;
	if(subset_y_end>=mosaicHeight)
		subset_y_end=mosaicHeight;

	//update the class variable
	m_width          = subset_x_end-subset_x_start;
	m_height         = subset_y_end-subset_y_start;
	m_leftLon      = mosaicLeftLon+subset_x_start*stepGridDegree;
	m_rightLon    = mosaicLeftLon+subset_x_end*stepGridDegree;
	m_upLat        = mosaicUpLat-subset_y_start*stepGridDegree;
	m_bottomLat = mosaicUpLat-subset_y_end*stepGridDegree;

	m_fdemData = new float[m_width*m_height];
	memset(m_sdemData, 0, m_width*m_height*sizeof(float));

	int i=0;
	for(i=0; i<m_height; i++)
	{
		memcpy(m_sdemData+i*m_width,  mosaicData+(i+subset_y_start)*mosaicWidth+subset_x_start, m_width*sizeof(float));
	}

	return 0;
}



int CDEMFileRead::NANProcess()
{
	int i, j;
	i = j = 0;
	
	if(m_sdemData!=NULL)
	{
		for (i=0; i<m_height; i++)
		{
			for(j=0; j<m_width; j++)
			{
				if((m_sdemData[i*m_width+j]<MIN_GROUND_HEIGHT*1.01)||(m_sdemData[i*m_width+j]>MAX_GROUND_HEIGHT*1.01))
				{
					m_sdemData[i*m_width+j]=0;
				}
			}
		}		
	}
	else if(m_fdemData!=NULL)
	{
		for (i=0; i<m_height; i++)
		{
			for(j=0; j<m_width; j++)
			{
				if((m_fdemData[i*m_width+j]<MIN_GROUND_HEIGHT/m_fRatioLevel)||(m_fdemData[i*m_width+j]>MAX_GROUND_HEIGHT/m_fRatioLevel))
				{
					m_sdemData[i*m_width+j]=0;
				}
			}
		}
	}

	return 0;
}


void CDEMFileRead::VRSS90DemGetFileName(double lat, double lon, char *lpszToDEM)
{	
	int V =(int)((100+ lon) * 2 + 2);
	int H =(int)((5  + lat)  * 3 + 1);

	sprintf(lpszToDEM, "%sDEM_%2d%2d_REGVEN.img", m_strVRSSDemFilePath, V, H);

	return;
}

bool CDEMFileRead::pixelToWorld(double x, double  y, double *lat, double *lon, double* geotransform, const char* lpszSR)
{
	OGRSpatialReferenceH  oSRS =OSRNewSpatialReference(lpszSR); 

	if(OSRIsProjected(oSRS))
	{
		OGRSpatialReferenceH   LatLongSR=OSRCloneGeogCS(oSRS);
		if (LatLongSR == NULL)
		{
			OSRDestroySpatialReference(oSRS);
			return false;
		}

		OGRCoordinateTransformationH poTransform =OCTNewCoordinateTransformation(oSRS ,LatLongSR);
		if (poTransform ==NULL)
		{
			OSRDestroySpatialReference(oSRS);
			OSRDestroySpatialReference(LatLongSR);
			return false;
		}

		GDALApplyGeoTransform(geotransform, x, y, lon, lat);
		OCTTransform(poTransform,1, lon, lat, NULL);

		OSRDestroySpatialReference(oSRS);
		OSRDestroySpatialReference(LatLongSR);
		OCTDestroyCoordinateTransformation(poTransform);
		return true;

	}
	else if (OSRIsGeographic(oSRS))
	{
		GDALApplyGeoTransform(geotransform, x, y, lon, lat);
		OSRDestroySpatialReference(oSRS);
		return true;
	}
	else
	{
		OSRDestroySpatialReference(oSRS);
		return false;
	}
}

bool CDEMFileRead::worldToPixel(double lat, double lon, double *x, double *y, double* geoTransform, const char* lpszSR)
{
	OGRSpatialReferenceH  oSRS =OSRNewSpatialReference(lpszSR); 

	if ( NULL == oSRS)
	{
		return false;
	}

	if(OSRIsProjected(oSRS))
	{
		OGRSpatialReferenceH   LatLongSR=OSRCloneGeogCS(oSRS);
		if (LatLongSR == NULL)
		{
			OSRDestroySpatialReference(oSRS);
			return false;
		}

		OGRCoordinateTransformationH poTransform =OCTNewCoordinateTransformation(LatLongSR, oSRS);
		if (poTransform == NULL)
		{	
			OSRDestroySpatialReference(oSRS);
			OSRDestroySpatialReference(LatLongSR);
			return false;
		}

		OCTTransform(poTransform,1, &lon, &lat,NULL);

		double  adfInverseGeoTransform[6];
		GDALInvGeoTransform(geoTransform, adfInverseGeoTransform);
		GDALApplyGeoTransform(adfInverseGeoTransform, lon,lat, x, y);
		OSRDestroySpatialReference(oSRS);
		OSRDestroySpatialReference(LatLongSR);
		OCTDestroyCoordinateTransformation(poTransform);
		return true;

	}
	else if (OSRIsGeographic(oSRS))
	{
		double  adfInverseGeoTransform[6];
		GDALInvGeoTransform(geoTransform, adfInverseGeoTransform);
		GDALApplyGeoTransform(adfInverseGeoTransform, lon,lat, x, y);
		OSRDestroySpatialReference(oSRS);
		return true;
	}
	else
	{
		OSRDestroySpatialReference(oSRS);
		return false;
	}
}

double CDEMFileRead::GetElevation(double lat, double lon)
{
	if (m_initBlockTag==1)
	{
		float dem_x = (float)((lon-m_leftLon)/m_stepGridDegree);
		float dem_y = (float)((m_upLat-lat)/m_stepGridDegree);

		float  fdem;
		short sdem;
		if (m_fdemData!=NULL)
		{
			fdem = Bilinear(dem_x, dem_y, m_width, m_height, m_fdemData);
			return (double)fdem;
		}
		else if(m_sdemData!=NULL)
		{
			sdem = Bilinear(dem_x, dem_y, m_width, m_height, m_sdemData);
			return (double)sdem;
		}
	}
	else
	{
		return GetElevationFromFile(lat, lon);
	}
}

double CDEMFileRead::GetElevationD(double X, double Y)
{
	return invalid_value;
}

double CDEMFileRead::GetElevationFromFile(double lat, double lon)
{
	char *lpszVRSS90DemFile = new char[512];
	char *lpszFree90DemFile  = new char[512];
	char *lpszFree30DemFile  = new char[512];

	Free30DemGetFileName(lat, lon, lpszFree30DemFile);
	Free90DemGetFileName(lat, lon, lpszFree90DemFile);
	VRSS90DemGetFileName(lat, lon, lpszVRSS90DemFile);

	CGDALFileManager *gdalImage = NULL;
	gdalImage = new CGDALFileManager;

	int bandArrayList[] = {1};
	int demGridCol, demGridRow;
	double block_lon, block_lat;
	int   pos_x, pos_y;
	short sdemValue[1];
	float  fdemValue[1];

	if(((_access(lpszVRSS90DemFile, 4 )) != -1)&&(gdalImage->LoadFrom(lpszVRSS90DemFile) != false))
	{
		demGridCol   = int((lon+180)/5)+1;
		demGridRow  = int((60.0-lat)/5)+1;
		
		m_stepGridDegree = 5.0/6000;

		block_lon= (demGridCol-1)*5-180;
		block_lat= 60-(demGridRow)*5;

		pos_x = int(((lon-block_lon)/m_stepGridDegree)+0.5);
		pos_y = int(6000-(lat-block_lat)/m_stepGridDegree+0.5);

		gdalImage->ReadImg(pos_x, pos_y, pos_x+1, pos_y+1, sdemValue, 1, 1, 1, bandArrayList, 0, 0, 0);

		return (double)fdemValue[0];
	}
	else if (((_access(lpszFree30DemFile, 4 )) != -1)&&(gdalImage->LoadFrom(lpszFree30DemFile) != false))
	{
		demGridCol   = int(lon);
		demGridRow  = int(lat);

		m_stepGridDegree = 1.0/3600;

		block_lon= demGridCol;
		block_lat = demGridRow;

		pos_x = int(((lon-block_lon)/m_stepGridDegree)+0.5);
		pos_y = int(3600-(lat-block_lat)/m_stepGridDegree+0.5);

		gdalImage->ReadImg(pos_x, pos_y, pos_x+1, pos_y+1, sdemValue, 1, 1, 1, bandArrayList, 0, 0, 0);

		return (double)sdemValue[0];
	}
	else if (((_access(lpszFree90DemFile, 4 )) != -1)&&(gdalImage->LoadFrom(lpszFree90DemFile) != false))
	{
		demGridCol   = int((lon+180)/5)+1;
		demGridRow  = int((60.0-lat)/5)+1;

		m_stepGridDegree = 5.0/6000;

		block_lon= (demGridCol-1)*5-180;
		block_lat= 60-(demGridRow-1)*5;

		pos_x = int(((lon-block_lon)/m_stepGridDegree)+0.5);
		pos_y = int((block_lat-lat)/m_stepGridDegree+0.5);

		gdalImage->ReadImg(pos_x, pos_y, pos_x+1, pos_y+1, sdemValue, 1, 1, 1, bandArrayList, 0, 0, 0);

		return (double)sdemValue[0];
	}
	else
	{
		printf("the image can't acess or load\n");
		return invalid_value;
	}

	delete [] lpszVRSS90DemFile;   lpszVRSS90DemFile=NULL;
	delete [] lpszFree30DemFile;    lpszFree30DemFile  =NULL;
	delete [] lpszFree90DemFile;    lpszFree90DemFile  =NULL;

	return invalid_value;
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
void CDEMFileRead::debugfortestWriteFile(char *fileName, int width, int hegith, void *databuff, int nbyte)
{
	FILE *fp = fopen(fileName, "wb");
	fwrite(databuff, nbyte, width*hegith, fp);
	fflush(fp);
	fclose(fp);
	fp = NULL;
}

